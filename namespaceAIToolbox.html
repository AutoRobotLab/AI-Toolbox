<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AIToolbox: AIToolbox Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIToolbox
   </div>
   <div id="projectbrief">A library that offers tools for AI problem solving.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AIToolbox Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceAIToolbox_1_1FactoredMDP"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1FactoredMDP.html">FactoredMDP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1Impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1Impl.html">Impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1MDP"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1POMDP"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1copy__const.html">copy_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to copy constness from one type to another.  <a href="structAIToolbox_1_1copy__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1EpsilonPolicyInterface.html">EpsilonPolicyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a policy wrapper for epsilon action choice.  <a href="classAIToolbox_1_1EpsilonPolicyInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1PolicyInterface.html">PolicyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base interface for policies.  <a href="classAIToolbox_1_1PolicyInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7fa914363e6f779a2ba9f92ea654b90a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a7fa914363e6f779a2ba9f92ea654b90a">Table3D</a> = boost::multi_array&lt; double, 3 &gt;</td></tr>
<tr class="separator:a7fa914363e6f779a2ba9f92ea654b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af774ebb18ec376e43d77e908e3854370"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#af774ebb18ec376e43d77e908e3854370">Table2D</a> = boost::multi_array&lt; double, 2 &gt;</td></tr>
<tr class="separator:af774ebb18ec376e43d77e908e3854370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d66d3e9eba8d23aeef6c6b865b6965a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor|Eigen::AutoAlign &gt;</td></tr>
<tr class="separator:a9d66d3e9eba8d23aeef6c6b865b6965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00da5abb5609a6454852aa726d67161"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a> = Eigen::SparseMatrix&lt; double, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:ab00da5abb5609a6454852aa726d67161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dac40c8fbdb76d149b6cbee1868b0c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a8dac40c8fbdb76d149b6cbee1868b0c9">SparseMatrix2DLong</a> = Eigen::SparseMatrix&lt; long, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a8dac40c8fbdb76d149b6cbee1868b0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6976de7a0159cd1630c4f2553fc9f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a1e6976de7a0159cd1630c4f2553fc9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae816d088c18d4f3e13c83ae29904ef94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ae816d088c18d4f3e13c83ae29904ef94">Matrix3D</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a> &gt;</td></tr>
<tr class="separator:ae816d088c18d4f3e13c83ae29904ef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d1ba8e10537e996faadb65f9c1fa77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a92d1ba8e10537e996faadb65f9c1fa77">SparseMatrix3D</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a> &gt;</td></tr>
<tr class="separator:a92d1ba8e10537e996faadb65f9c1fa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1d4d92e6349e16ab51cc2b3b328750"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a1c1d4d92e6349e16ab51cc2b3b328750">SparseMatrix3DLong</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#a8dac40c8fbdb76d149b6cbee1868b0c9">SparseMatrix2DLong</a> &gt;</td></tr>
<tr class="separator:a1c1d4d92e6349e16ab51cc2b3b328750"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adf3316313e5c38bb940a665f55db9a04"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:adf3316313e5c38bb940a665f55db9a04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#adf3316313e5c38bb940a665f55db9a04">copyTable3D</a> (const T &amp;in, U &amp;out, const size_t d1, const size_t d2, const size_t d3)</td></tr>
<tr class="memdesc:adf3316313e5c38bb940a665f55db9a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 3d container into another 3d container.  <a href="#adf3316313e5c38bb940a665f55db9a04">More...</a><br /></td></tr>
<tr class="separator:adf3316313e5c38bb940a665f55db9a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164ff36d8475927a491a18c990a9e199"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a164ff36d8475927a491a18c990a9e199">checkEqualSmall</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a164ff36d8475927a491a18c990a9e199"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles near [0,1] are reasonably equal.  <a href="#a164ff36d8475927a491a18c990a9e199">More...</a><br /></td></tr>
<tr class="separator:a164ff36d8475927a491a18c990a9e199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1da51b88333c412b0978a7e95581f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#add1da51b88333c412b0978a7e95581f1">checkDifferentSmall</a> (const double a, const double b)</td></tr>
<tr class="memdesc:add1da51b88333c412b0978a7e95581f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles near [0,1] are reasonably different.  <a href="#add1da51b88333c412b0978a7e95581f1">More...</a><br /></td></tr>
<tr class="separator:add1da51b88333c412b0978a7e95581f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb49a3d6b7ce2588edec044a541e88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a1cb49a3d6b7ce2588edec044a541e88e">checkEqualGeneral</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a1cb49a3d6b7ce2588edec044a541e88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles are reasonably equal.  <a href="#a1cb49a3d6b7ce2588edec044a541e88e">More...</a><br /></td></tr>
<tr class="separator:a1cb49a3d6b7ce2588edec044a541e88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f283ebe30cd11e1eead7a814057945"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a67f283ebe30cd11e1eead7a814057945">checkDifferentGeneral</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a67f283ebe30cd11e1eead7a814057945"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles are reasonably different.  <a href="#a67f283ebe30cd11e1eead7a814057945">More...</a><br /></td></tr>
<tr class="separator:a67f283ebe30cd11e1eead7a814057945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111282b4c465f34023497869fdeecd58"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a111282b4c465f34023497869fdeecd58"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a111282b4c465f34023497869fdeecd58">veccmp</a> (const V &amp;lhs, const V &amp;rhs)</td></tr>
<tr class="memdesc:a111282b4c465f34023497869fdeecd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two AIToolbox::Vectors of equal size.  <a href="#a111282b4c465f34023497869fdeecd58">More...</a><br /></td></tr>
<tr class="separator:a111282b4c465f34023497869fdeecd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55704f3d804db6f45c52e6d2fb539d2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a55704f3d804db6f45c52e6d2fb539d2c">operator&lt;</a> (const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;lhs, const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;rhs)</td></tr>
<tr class="separator:a55704f3d804db6f45c52e6d2fb539d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38827c4e5e28f647a2cd272eadf52a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aa38827c4e5e28f647a2cd272eadf52a1">operator&gt;</a> (const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;lhs, const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;rhs)</td></tr>
<tr class="separator:aa38827c4e5e28f647a2cd272eadf52a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39713f004f1572ab84fb4ab4d9f44f3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:aa39713f004f1572ab84fb4ab4d9f44f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aa39713f004f1572ab84fb4ab4d9f44f3">sequential_sorted_contains</a> (const V &amp;v, decltype(v[0]) elem)</td></tr>
<tr class="memdesc:aa39713f004f1572ab84fb4ab4d9f44f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether a sorted range contains a given element, via sequential scan.  <a href="#aa39713f004f1572ab84fb4ab4d9f44f3">More...</a><br /></td></tr>
<tr class="separator:aa39713f004f1572ab84fb4ab4d9f44f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c2589bdd0571ce9bfd643b38e51f64"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a11c2589bdd0571ce9bfd643b38e51f64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structAIToolbox_1_1Impl_1_1BaseIter.html">Impl::BaseIter</a>&lt; Iterator &gt;::BaseIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a11c2589bdd0571ce9bfd643b38e51f64">baseIter</a> (const Iterator &amp;it)</td></tr>
<tr class="memdesc:a11c2589bdd0571ce9bfd643b38e51f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the base iterator for any given iterator.  <a href="#a11c2589bdd0571ce9bfd643b38e51f64">More...</a><br /></td></tr>
<tr class="separator:a11c2589bdd0571ce9bfd643b38e51f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4052078699d21068b648273ec9dcf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d4052078699d21068b648273ec9dcf6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a5d4052078699d21068b648273ec9dcf6">isProbability</a> (const size_t d, const T &amp;in)</td></tr>
<tr class="memdesc:a5d4052078699d21068b648273ec9dcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether the supplied vector is a correct probability vector.  <a href="#a5d4052078699d21068b648273ec9dcf6">More...</a><br /></td></tr>
<tr class="separator:a5d4052078699d21068b648273ec9dcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename G &gt; </td></tr>
<tr class="memitem:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad73352f6ce65aa95f76b7399cf0d2cb0">sampleProbability</a> (const size_t d, const T &amp;in, G &amp;generator)</td></tr>
<tr class="memdesc:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples an index from a probability vector.  <a href="#ad73352f6ce65aa95f76b7399cf0d2cb0">More...</a><br /></td></tr>
<tr class="separator:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bee222a80dcc928ff58471e7a8274c"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a07bee222a80dcc928ff58471e7a8274c"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a07bee222a80dcc928ff58471e7a8274c">sampleProbability</a> (const size_t d, const SparseMatrix2D::RowXpr &amp;in, G &amp;generator)</td></tr>
<tr class="memdesc:a07bee222a80dcc928ff58471e7a8274c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples an index from a sparse probability vector.  <a href="#a07bee222a80dcc928ff58471e7a8274c">More...</a><br /></td></tr>
<tr class="separator:a07bee222a80dcc928ff58471e7a8274c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a31fb7fd3eb6b455f39a1bd388a5fd264">sampleProbability</a> (const size_t d, const SparseMatrix2D::ConstRowXpr &amp;in, G &amp;generator)</td></tr>
<tr class="memdesc:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples an index from a sparse probability vector.  <a href="#a31fb7fd3eb6b455f39a1bd388a5fd264">More...</a><br /></td></tr>
<tr class="separator:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6f194bb6328d8a92149895e8cd771c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a9b6f194bb6328d8a92149895e8cd771c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a9b6f194bb6328d8a92149895e8cd771c">normalizeProbability</a> (InputIterator begin, InputIterator end, OutputIterator out)</td></tr>
<tr class="memdesc:a9b6f194bb6328d8a92149895e8cd771c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function normalizes a container so that it sums to 1.0.  <a href="#a9b6f194bb6328d8a92149895e8cd771c">More...</a><br /></td></tr>
<tr class="separator:a9b6f194bb6328d8a92149895e8cd771c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea709246c227f35a91ffaa8de6e5c8d0"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aea709246c227f35a91ffaa8de6e5c8d0"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aea709246c227f35a91ffaa8de6e5c8d0">extractDominated</a> (const size_t N, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:aea709246c227f35a91ffaa8de6e5c8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves all Vectors in the range that are dominated by others.  <a href="#aea709246c227f35a91ffaa8de6e5c8d0">More...</a><br /></td></tr>
<tr class="separator:aea709246c227f35a91ffaa8de6e5c8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a9d66d3e9eba8d23aeef6c6b865b6965a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">AIToolbox::Matrix2D</a> = typedef Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor | Eigen::AutoAlign&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae816d088c18d4f3e13c83ae29904ef94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ae816d088c18d4f3e13c83ae29904ef94">AIToolbox::Matrix3D</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab00da5abb5609a6454852aa726d67161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">AIToolbox::SparseMatrix2D</a> = typedef Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8dac40c8fbdb76d149b6cbee1868b0c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a8dac40c8fbdb76d149b6cbee1868b0c9">AIToolbox::SparseMatrix2DLong</a> = typedef Eigen::SparseMatrix&lt;long, Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a92d1ba8e10537e996faadb65f9c1fa77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a92d1ba8e10537e996faadb65f9c1fa77">AIToolbox::SparseMatrix3D</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c1d4d92e6349e16ab51cc2b3b328750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a1c1d4d92e6349e16ab51cc2b3b328750">AIToolbox::SparseMatrix3DLong</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#a8dac40c8fbdb76d149b6cbee1868b0c9">SparseMatrix2DLong</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af774ebb18ec376e43d77e908e3854370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#af774ebb18ec376e43d77e908e3854370">AIToolbox::Table2D</a> = typedef boost::multi_array&lt;double, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7fa914363e6f779a2ba9f92ea654b90a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a7fa914363e6f779a2ba9f92ea654b90a">AIToolbox::Table3D</a> = typedef boost::multi_array&lt;double, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e6976de7a0159cd1630c4f2553fc9f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">AIToolbox::Vector</a> = typedef Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a11c2589bdd0571ce9bfd643b38e51f64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAIToolbox_1_1Impl_1_1BaseIter.html">Impl::BaseIter</a>&lt;Iterator&gt;::BaseIterator AIToolbox::baseIter </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the base iterator for any given iterator. </p>
<p>A base iterator exists if the iterator implements the method base(). If not, a copy of the same iterator is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to return the base of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The base iterator of the input. </dd></dl>

</div>
</div>
<a class="anchor" id="a67f283ebe30cd11e1eead7a814057945"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentGeneral </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles are reasonably different. </p>
<p>The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are far away enough, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="add1da51b88333c412b0978a7e95581f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentSmall </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles near [0,1] are reasonably different. </p>
<p>If the numbers are not near [0,1], the result is not guaranteed to be what may be expected. The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are far away enough, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cb49a3d6b7ce2588edec044a541e88e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualGeneral </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles are reasonably equal. </p>
<p>The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are close enough, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a164ff36d8475927a491a18c990a9e199"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualSmall </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles near [0,1] are reasonably equal. </p>
<p>If the numbers are not near [0,1], the result is not guaranteed to be what may be expected. The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are close enough, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="adf3316313e5c38bb940a665f55db9a04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::copyTable3D </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a 3d container into another 3d container. </p>
<p>The containers needs to support data access through operator[]. In addition, the dimensions of the containers must match the ones specified.</p>
<p>This is important, as this function DOES NOT perform any size checks on the containers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the input container. </td></tr>
    <tr><td class="paramname">U</td><td>Type of the output container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input container. </td></tr>
    <tr><td class="paramname">out</td><td>Output container. </td></tr>
    <tr><td class="paramname">d1</td><td>First dimension of the containers. </td></tr>
    <tr><td class="paramname">d2</td><td>Second dimension of the containers. </td></tr>
    <tr><td class="paramname">d3</td><td>Third dimension of the containers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea709246c227f35a91ffaa8de6e5c8d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::extractDominated </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves all Vectors in the range that are dominated by others. </p>
<p>This function performs simple comparisons between all Vectors in the range, and is thus much more performant than a full-fledged prune, since that would need to solve multiple linear programming problems. However, this function will not return the truly parsimonious set of Vectors, as its pruning powers are limited.</p>
<p>Dominated elements will be moved at the end of the range for safe removal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The number of elements in each Vector. </td></tr>
    <tr><td class="paramname">begin</td><td>The begin of the list that needs to be pruned. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the list that needs to be pruned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator that separates dominated elements with non-pruned. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d4052078699d21068b648273ec9dcf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::isProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether the supplied vector is a correct probability vector. </p>
<p>This function verifies basic probability conditions on the supplied container. The sum of all elements must be 1, and all elements must be &gt;= 0 and &lt;= 1.</p>
<p>The container needs to support data access through operator[]. In addition, the dimension of the container must match the one provided as argument.</p>
<p>This is important, as this function DOES NOT perform any size checks on the external container.</p>
<p>Internal values of the container will be converted to double, so the conversion T to double must be possible.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The external transition container type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external transitions container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the container satisfies probability constraints, and false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b6f194bb6328d8a92149895e8cd771c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::normalizeProbability </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function normalizes a container so that it sums to 1.0. </p>
<p>If the provided container sums to 0.0, then the first element in the output range becomes 1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The beginning of the range to normalize. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to normalize. </td></tr>
    <tr><td class="paramname">out</td><td>The beginning of the output range (can be the same as begin). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55704f3d804db6f45c52e6d2fb539d2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa38827c4e5e28f647a2cd272eadf52a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad73352f6ce65aa95f76b7399cf0d2cb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t AIToolbox::sampleProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples an index from a probability vector. </p>
<p>This function randomly samples an index between 0 and d, given a vector containing the probabilities of sampling each of the indexes.</p>
<p>For performance reasons this function does not verify that the input container is effectively a probability.</p>
<p>The generator has to be supplied to the function, so that different objects are able to maintain different generators, to reduce correlations between different samples. The generator has to be compatible with std::uniform_real_distribution&lt;double&gt;, since that is what is used to obtain the random sample.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the container vector to sample. </td></tr>
    <tr><td class="paramname">G</td><td>The type of the generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external probability container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container. </td></tr>
    <tr><td class="paramname">generator</td><td>The generator used to sample.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index in range [0,d-1]. </dd></dl>

</div>
</div>
<a class="anchor" id="a07bee222a80dcc928ff58471e7a8274c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t AIToolbox::sampleProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseMatrix2D::RowXpr &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples an index from a sparse probability vector. </p>
<p>This function randomly samples an index between 0 and d, given a vector containing the probabilities of sampling each of the indexes.</p>
<p>For performance reasons this function does not verify that the input container is effectively a probability.</p>
<p>The generator has to be supplied to the function, so that different objects are able to maintain different generators, to reduce correlations between different samples. The generator has to be compatible with std::uniform_real_distribution&lt;double&gt;, since that is what is used to obtain the random sample.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>The type of the generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external probability container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container. </td></tr>
    <tr><td class="paramname">generator</td><td>The generator used to sample.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index in range [0,d-1]. </dd></dl>

</div>
</div>
<a class="anchor" id="a31fb7fd3eb6b455f39a1bd388a5fd264"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t AIToolbox::sampleProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseMatrix2D::ConstRowXpr &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples an index from a sparse probability vector. </p>
<p>This function randomly samples an index between 0 and d, given a vector containing the probabilities of sampling each of the indexes.</p>
<p>For performance reasons this function does not verify that the input container is effectively a probability.</p>
<p>The generator has to be supplied to the function, so that different objects are able to maintain different generators, to reduce correlations between different samples. The generator has to be compatible with std::uniform_real_distribution&lt;double&gt;, since that is what is used to obtain the random sample.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>The type of the generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external probability container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container. </td></tr>
    <tr><td class="paramname">generator</td><td>The generator used to sample.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index in range [0,d-1]. </dd></dl>

</div>
</div>
<a class="anchor" id="aa39713f004f1572ab84fb4ab4d9f44f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::sequential_sorted_contains </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">decltype(v[0])&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether a sorted range contains a given element, via sequential scan. </p>
<p>The idea behind this function is that for small sorted vectors it is faster to do a sequential scan rather than employing the heavy handed technique of binary search.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The type of the vector to be scanned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to be scanned. </td></tr>
    <tr><td class="paramname">elem</td><td>The element to be looked for in the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vector contains that element, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a111282b4c465f34023497869fdeecd58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int AIToolbox::veccmp </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two AIToolbox::Vectors of equal size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand size of the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand size of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the lhs is greater than the rhs, 0 if they are equal, -1 otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 4 2017 15:14:44 for AIToolbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
