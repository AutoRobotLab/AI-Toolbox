<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIToolbox: AIToolbox Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIToolbox
   </div>
   <div id="projectbrief">A library that offers tools for AI problem solving.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">AIToolbox Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceAIToolbox_1_1Bandit"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1Bandit.html">Bandit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1Factored"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1Factored.html">Factored</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1Impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1Impl.html">Impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1MDP"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceAIToolbox_1_1POMDP"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox_1_1POMDP.html">POMDP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1copy__const.html">copy_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to copy constness from one type to another.  <a href="structAIToolbox_1_1copy__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1EpsilonPolicyInterface.html">EpsilonPolicyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a policy wrapper for epsilon action choice.  <a href="classAIToolbox_1_1EpsilonPolicyInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1EpsilonPolicyInterface_3_01void_00_01void_00_01Action_01_4.html">EpsilonPolicyInterface&lt; void, void, Action &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base interface for epsilon policies in games and bandits.  <a href="classAIToolbox_1_1EpsilonPolicyInterface_3_01void_00_01void_00_01Action_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1IndexMap.html">IndexMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an iterable construct on a list of ids on a given container.  <a href="classAIToolbox_1_1IndexMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1IndexMapIterator.html">IndexMapIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a simple iterator to iterate over a container with the specified ids.  <a href="classAIToolbox_1_1IndexMapIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1IndexSkipMap.html">IndexSkipMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an iterable construct on a list of ids on a given container.  <a href="classAIToolbox_1_1IndexSkipMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1IndexSkipMapIterator.html">IndexSkipMapIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a simple iterator to iterate over a container without the specified ids.  <a href="classAIToolbox_1_1IndexSkipMapIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1LP.html">LP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class presents a common interface for solving Linear Programming problems.  <a href="classAIToolbox_1_1LP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1NoCheck.html">NoCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to tag functions that avoid runtime checks.  <a href="structAIToolbox_1_1NoCheck.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1PolicyInterface.html">PolicyInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base interface for policies.  <a href="classAIToolbox_1_1PolicyInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1PolicyInterface_3_01void_00_01void_00_01Action_01_4.html">PolicyInterface&lt; void, void, Action &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base interface for policies in games and bandits.  <a href="classAIToolbox_1_1PolicyInterface_3_01void_00_01void_00_01Action_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Pruner.html">Pruner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers pruning facilities for non-parsimonious ValueFunction sets.  <a href="classAIToolbox_1_1Pruner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIToolbox_1_1remove__cv__ref.html">remove_cv_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is used to both remove references and all cv qualifiers.  <a href="structAIToolbox_1_1remove__cv__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1Statistics.html">Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class registers sets of data and computes statistics about it.  <a href="classAIToolbox_1_1Statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1SubsetEnumerator.html">SubsetEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class enumerates all possible vectors of finite subsets over N elements.  <a href="classAIToolbox_1_1SubsetEnumerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1VoseAliasSampler.html">VoseAliasSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the Alias sampling method.  <a href="classAIToolbox_1_1VoseAliasSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIToolbox_1_1WitnessLP.html">WitnessLP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements an easy interface to do Witness discovery through linear programming.  <a href="classAIToolbox_1_1WitnessLP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af6eb1f8c89dcca62cbe9912b6ec77d33"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#af6eb1f8c89dcca62cbe9912b6ec77d33">AILoggerFun</a> = void(int, const char *)</td></tr>
<tr class="separator:af6eb1f8c89dcca62cbe9912b6ec77d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b5db736a97adb3698ffa04ea3f4aa4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a09b5db736a97adb3698ffa04ea3f4aa4">RandomEngine</a> = std::mt19937</td></tr>
<tr class="separator:a09b5db736a97adb3698ffa04ea3f4aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa914363e6f779a2ba9f92ea654b90a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a7fa914363e6f779a2ba9f92ea654b90a">Table3D</a> = boost::multi_array&lt; double, 3 &gt;</td></tr>
<tr class="separator:a7fa914363e6f779a2ba9f92ea654b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af774ebb18ec376e43d77e908e3854370"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#af774ebb18ec376e43d77e908e3854370">Table2D</a> = boost::multi_array&lt; double, 2 &gt;</td></tr>
<tr class="separator:af774ebb18ec376e43d77e908e3854370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6976de7a0159cd1630c4f2553fc9f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a1e6976de7a0159cd1630c4f2553fc9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d66d3e9eba8d23aeef6c6b865b6965a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor|Eigen::AutoAlign &gt;</td></tr>
<tr class="separator:a9d66d3e9eba8d23aeef6c6b865b6965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00da5abb5609a6454852aa726d67161"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a> = Eigen::SparseMatrix&lt; double, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:ab00da5abb5609a6454852aa726d67161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dac40c8fbdb76d149b6cbee1868b0c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a8dac40c8fbdb76d149b6cbee1868b0c9">SparseMatrix2DLong</a> = Eigen::SparseMatrix&lt; long, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a8dac40c8fbdb76d149b6cbee1868b0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae816d088c18d4f3e13c83ae29904ef94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ae816d088c18d4f3e13c83ae29904ef94">Matrix3D</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a> &gt;</td></tr>
<tr class="separator:ae816d088c18d4f3e13c83ae29904ef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d1ba8e10537e996faadb65f9c1fa77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a92d1ba8e10537e996faadb65f9c1fa77">SparseMatrix3D</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a> &gt;</td></tr>
<tr class="separator:a92d1ba8e10537e996faadb65f9c1fa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1d4d92e6349e16ab51cc2b3b328750"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a1c1d4d92e6349e16ab51cc2b3b328750">SparseMatrix3DLong</a> = std::vector&lt; <a class="el" href="namespaceAIToolbox.html#a8dac40c8fbdb76d149b6cbee1868b0c9">SparseMatrix2DLong</a> &gt;</td></tr>
<tr class="separator:a1c1d4d92e6349e16ab51cc2b3b328750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7541eece4eef765b312dc4b686852d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aaa7541eece4eef765b312dc4b686852d">Matrix4D</a> = boost::multi_array&lt; <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a>, 2 &gt;</td></tr>
<tr class="separator:aaa7541eece4eef765b312dc4b686852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5615bfca915406da608cea51152cfe5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a5615bfca915406da608cea51152cfe5b">SparseMatrix4D</a> = boost::multi_array&lt; <a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a>, 2 &gt;</td></tr>
<tr class="separator:a5615bfca915406da608cea51152cfe5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4149b71e91dee03ad9d0c8c207eddf0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> = <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td></tr>
<tr class="separator:af4149b71e91dee03ad9d0c8c207eddf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967d7ac0afaa61470bc00b04df196dca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">Hyperplane</a> = <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td></tr>
<tr class="separator:a967d7ac0afaa61470bc00b04df196dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc5e85a0aaffacedefb093e4cbef173"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">Point</a> = <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td></tr>
<tr class="separator:a9fc5e85a0aaffacedefb093e4cbef173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f932b6473be1c052e5f14aa85180d0"><td class="memTemplParams" colspan="2">template&lt;typename CopiedType , typename ConstReference &gt; </td></tr>
<tr class="memitem:ae1f932b6473be1c052e5f14aa85180d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ae1f932b6473be1c052e5f14aa85180d0">copy_const_t</a> = typename <a class="el" href="structAIToolbox_1_1copy__const.html">copy_const</a>&lt; CopiedType, ConstReference &gt;::type</td></tr>
<tr class="separator:ae1f932b6473be1c052e5f14aa85180d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f42a5910cd868eb0af71b7491d420d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03f42a5910cd868eb0af71b7491d420d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a03f42a5910cd868eb0af71b7491d420d">remove_cv_ref_t</a> = typename <a class="el" href="structAIToolbox_1_1remove__cv__ref.html">remove_cv_ref</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a03f42a5910cd868eb0af71b7491d420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ca50b6d2585387be42d0ae76205f34a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a6ca50b6d2585387be42d0ae76205f34a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classAIToolbox_1_1Statistics.html">Statistics</a> &amp;rh)</td></tr>
<tr class="memdesc:a6ca50b6d2585387be42d0ae76205f34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the output of the <a class="el" href="classAIToolbox_1_1Statistics.html" title="This class registers sets of data and computes statistics about it. ">Statistics</a> to the stream.  <a href="#a6ca50b6d2585387be42d0ae76205f34a">More...</a><br /></td></tr>
<tr class="separator:a6ca50b6d2585387be42d0ae76205f34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5a791c00b531a438fd130591ee0809"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ade5a791c00b531a438fd130591ee0809">nChooseK</a> (unsigned n, unsigned k)</td></tr>
<tr class="memdesc:ade5a791c00b531a438fd130591ee0809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns (n k); i.e. n choose k.  <a href="#ade5a791c00b531a438fd130591ee0809">More...</a><br /></td></tr>
<tr class="separator:ade5a791c00b531a438fd130591ee0809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2c6fcda7af327c205dae20fc162d35"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#acc2c6fcda7af327c205dae20fc162d35">starsBars</a> (unsigned stars, unsigned bars)</td></tr>
<tr class="memdesc:acc2c6fcda7af327c205dae20fc162d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of stars/bars combinations.  <a href="#acc2c6fcda7af327c205dae20fc162d35">More...</a><br /></td></tr>
<tr class="separator:acc2c6fcda7af327c205dae20fc162d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6c1c85280fc7a2d5c2cf96c72ca770"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a9f6c1c85280fc7a2d5c2cf96c72ca770">ballsBins</a> (unsigned balls, unsigned bins)</td></tr>
<tr class="memdesc:a9f6c1c85280fc7a2d5c2cf96c72ca770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of balls/bins combinations.  <a href="#a9f6c1c85280fc7a2d5c2cf96c72ca770">More...</a><br /></td></tr>
<tr class="separator:a9f6c1c85280fc7a2d5c2cf96c72ca770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089de7e55bbd13310ce6f3d5296932af"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a089de7e55bbd13310ce6f3d5296932af">nonZeroStarsBars</a> (unsigned stars, unsigned bars)</td></tr>
<tr class="memdesc:a089de7e55bbd13310ce6f3d5296932af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of stars/bars combinations.  <a href="#a089de7e55bbd13310ce6f3d5296932af">More...</a><br /></td></tr>
<tr class="separator:a089de7e55bbd13310ce6f3d5296932af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecaab4f7eee1001fa0c46fb93c98201"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aaecaab4f7eee1001fa0c46fb93c98201">nonZeroBallsBins</a> (unsigned balls, unsigned bins)</td></tr>
<tr class="memdesc:aaecaab4f7eee1001fa0c46fb93c98201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of balls/bins combinations.  <a href="#aaecaab4f7eee1001fa0c46fb93c98201">More...</a><br /></td></tr>
<tr class="separator:aaecaab4f7eee1001fa0c46fb93c98201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3316313e5c38bb940a665f55db9a04"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:adf3316313e5c38bb940a665f55db9a04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#adf3316313e5c38bb940a665f55db9a04">copyTable3D</a> (const T &amp;in, U &amp;out, const size_t d1, const size_t d2, const size_t d3)</td></tr>
<tr class="memdesc:adf3316313e5c38bb940a665f55db9a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 3d container into another 3d container.  <a href="#adf3316313e5c38bb940a665f55db9a04">More...</a><br /></td></tr>
<tr class="separator:adf3316313e5c38bb940a665f55db9a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164ff36d8475927a491a18c990a9e199"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a164ff36d8475927a491a18c990a9e199">checkEqualSmall</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a164ff36d8475927a491a18c990a9e199"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles near [0,1] are reasonably equal.  <a href="#a164ff36d8475927a491a18c990a9e199">More...</a><br /></td></tr>
<tr class="separator:a164ff36d8475927a491a18c990a9e199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1da51b88333c412b0978a7e95581f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#add1da51b88333c412b0978a7e95581f1">checkDifferentSmall</a> (const double a, const double b)</td></tr>
<tr class="memdesc:add1da51b88333c412b0978a7e95581f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles near [0,1] are reasonably different.  <a href="#add1da51b88333c412b0978a7e95581f1">More...</a><br /></td></tr>
<tr class="separator:add1da51b88333c412b0978a7e95581f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb49a3d6b7ce2588edec044a541e88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a1cb49a3d6b7ce2588edec044a541e88e">checkEqualGeneral</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a1cb49a3d6b7ce2588edec044a541e88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles are reasonably equal.  <a href="#a1cb49a3d6b7ce2588edec044a541e88e">More...</a><br /></td></tr>
<tr class="separator:a1cb49a3d6b7ce2588edec044a541e88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f283ebe30cd11e1eead7a814057945"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a67f283ebe30cd11e1eead7a814057945">checkDifferentGeneral</a> (const double a, const double b)</td></tr>
<tr class="memdesc:a67f283ebe30cd11e1eead7a814057945"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if two doubles are reasonably different.  <a href="#a67f283ebe30cd11e1eead7a814057945">More...</a><br /></td></tr>
<tr class="separator:a67f283ebe30cd11e1eead7a814057945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18765a780a9488b129cb8334e16e370a"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a18765a780a9488b129cb8334e16e370a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a18765a780a9488b129cb8334e16e370a">checkEqualSmall</a> (const V &amp;v, const double d)</td></tr>
<tr class="memdesc:a18765a780a9488b129cb8334e16e370a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a given vector only contains the stated value.  <a href="#a18765a780a9488b129cb8334e16e370a">More...</a><br /></td></tr>
<tr class="separator:a18765a780a9488b129cb8334e16e370a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6797db6216af3a252546a74690bda979"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a6797db6216af3a252546a74690bda979"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a6797db6216af3a252546a74690bda979">checkDifferentSmall</a> (const V &amp;v, const double d)</td></tr>
<tr class="memdesc:a6797db6216af3a252546a74690bda979"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a given vector does not contain only the stated value.  <a href="#a6797db6216af3a252546a74690bda979">More...</a><br /></td></tr>
<tr class="separator:a6797db6216af3a252546a74690bda979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71946ca7560a469505d9e449841b40d1"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a71946ca7560a469505d9e449841b40d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a71946ca7560a469505d9e449841b40d1">checkEqualGeneral</a> (const V &amp;v, const double d)</td></tr>
<tr class="memdesc:a71946ca7560a469505d9e449841b40d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a given vector only contains the stated value.  <a href="#a71946ca7560a469505d9e449841b40d1">More...</a><br /></td></tr>
<tr class="separator:a71946ca7560a469505d9e449841b40d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65413c83ea777c89684f5d901ea33679"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a65413c83ea777c89684f5d901ea33679"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a65413c83ea777c89684f5d901ea33679">checkDifferentGeneral</a> (const V &amp;v, const double d)</td></tr>
<tr class="memdesc:a65413c83ea777c89684f5d901ea33679"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether a given vector does not contain only the stated value.  <a href="#a65413c83ea777c89684f5d901ea33679">More...</a><br /></td></tr>
<tr class="separator:a65413c83ea777c89684f5d901ea33679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111282b4c465f34023497869fdeecd58"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a111282b4c465f34023497869fdeecd58"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a111282b4c465f34023497869fdeecd58">veccmp</a> (const V &amp;lhs, const V &amp;rhs)</td></tr>
<tr class="memdesc:a111282b4c465f34023497869fdeecd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two general vectors of equal size lexicographically.  <a href="#a111282b4c465f34023497869fdeecd58">More...</a><br /></td></tr>
<tr class="separator:a111282b4c465f34023497869fdeecd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0927a8f10c7aa36aa7d341fab1834fc"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ad0927a8f10c7aa36aa7d341fab1834fc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad0927a8f10c7aa36aa7d341fab1834fc">veccmpSmall</a> (const V &amp;lhs, const V &amp;rhs)</td></tr>
<tr class="memdesc:ad0927a8f10c7aa36aa7d341fab1834fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two general vectors of equal size lexicographically.  <a href="#ad0927a8f10c7aa36aa7d341fab1834fc">More...</a><br /></td></tr>
<tr class="separator:ad0927a8f10c7aa36aa7d341fab1834fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad90c42f9cf72812707724c6a669161"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a2ad90c42f9cf72812707724c6a669161"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a2ad90c42f9cf72812707724c6a669161">veccmpGeneral</a> (const V &amp;lhs, const V &amp;rhs)</td></tr>
<tr class="memdesc:a2ad90c42f9cf72812707724c6a669161"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two general vectors of equal size lexicographically.  <a href="#a2ad90c42f9cf72812707724c6a669161">More...</a><br /></td></tr>
<tr class="separator:a2ad90c42f9cf72812707724c6a669161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39713f004f1572ab84fb4ab4d9f44f3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:aa39713f004f1572ab84fb4ab4d9f44f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aa39713f004f1572ab84fb4ab4d9f44f3">sequential_sorted_contains</a> (const V &amp;v, decltype(v[0]) elem)</td></tr>
<tr class="memdesc:aa39713f004f1572ab84fb4ab4d9f44f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether a sorted range contains a given element, via sequential scan.  <a href="#aa39713f004f1572ab84fb4ab4d9f44f3">More...</a><br /></td></tr>
<tr class="separator:aa39713f004f1572ab84fb4ab4d9f44f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9131cfadf0600e435b545dbf0b5fc9"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:acb9131cfadf0600e435b545dbf0b5fc9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#acb9131cfadf0600e435b545dbf0b5fc9">sequential_sorted_contains</a> (const V &amp;v, const V &amp;elems)</td></tr>
<tr class="memdesc:acb9131cfadf0600e435b545dbf0b5fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns whether a sorted range contains another sorted range, via sequential scan.  <a href="#acb9131cfadf0600e435b545dbf0b5fc9">More...</a><br /></td></tr>
<tr class="separator:acb9131cfadf0600e435b545dbf0b5fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc040c10bbec513dac4ee154328d799f"><td class="memTemplParams" colspan="2">template&lt;class T , class Container &gt; </td></tr>
<tr class="memitem:afc040c10bbec513dac4ee154328d799f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#afc040c10bbec513dac4ee154328d799f">IndexMap</a> (std::initializer_list&lt; T &gt; i, Container c) -&gt; <a class="el" href="classAIToolbox_1_1IndexMap.html">IndexMap</a>&lt; std::vector&lt; T &gt;, Container &gt;</td></tr>
<tr class="separator:afc040c10bbec513dac4ee154328d799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad1be4bb3c810a6b25373d91a28038e"><td class="memTemplParams" colspan="2">template&lt;class T , class Container &gt; </td></tr>
<tr class="memitem:a0ad1be4bb3c810a6b25373d91a28038e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a0ad1be4bb3c810a6b25373d91a28038e">IndexSkipMap</a> (std::initializer_list&lt; T &gt; i, Container c) -&gt; <a class="el" href="classAIToolbox_1_1IndexSkipMap.html">IndexSkipMap</a>&lt; std::vector&lt; T &gt;, Container &gt;</td></tr>
<tr class="separator:a0ad1be4bb3c810a6b25373d91a28038e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdeffa64d9078567c3d3e61e92cf0c6f"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:acdeffa64d9078567c3d3e61e92cf0c6f"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#acdeffa64d9078567c3d3e61e92cf0c6f">findBestAtPoint</a> (const <a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">Point</a> &amp;p, Iterator begin, Iterator end, double *value=nullptr)</td></tr>
<tr class="memdesc:acdeffa64d9078567c3d3e61e92cf0c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns an iterator pointing to the best Hyperplane for the specified point.  <a href="#acdeffa64d9078567c3d3e61e92cf0c6f">More...</a><br /></td></tr>
<tr class="separator:acdeffa64d9078567c3d3e61e92cf0c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fa3979f3ccb728db8fd16668bce211"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a69fa3979f3ccb728db8fd16668bce211"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a69fa3979f3ccb728db8fd16668bce211">findBestAtSimplexCorner</a> (const size_t corner, Iterator begin, Iterator end, double *value=nullptr)</td></tr>
<tr class="memdesc:a69fa3979f3ccb728db8fd16668bce211"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns an iterator pointing to the best Hyperplane for the specified corner of the simplex space.  <a href="#a69fa3979f3ccb728db8fd16668bce211">More...</a><br /></td></tr>
<tr class="separator:a69fa3979f3ccb728db8fd16668bce211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861a12a2c8b1399d1ee2da0af575481c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a861a12a2c8b1399d1ee2da0af575481c"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a861a12a2c8b1399d1ee2da0af575481c">extractBestAtPoint</a> (const <a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">Point</a> &amp;p, Iterator begin, Iterator bound, Iterator end)</td></tr>
<tr class="memdesc:a861a12a2c8b1399d1ee2da0af575481c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves the Hyperplane with the highest value for the given point at the beginning of the specified range.  <a href="#a861a12a2c8b1399d1ee2da0af575481c">More...</a><br /></td></tr>
<tr class="separator:a861a12a2c8b1399d1ee2da0af575481c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ca8083da245fef389ebea24fb5b2ef"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aa5ca8083da245fef389ebea24fb5b2ef"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aa5ca8083da245fef389ebea24fb5b2ef">extractBestAtSimplexCorners</a> (const size_t S, Iterator begin, Iterator bound, Iterator end)</td></tr>
<tr class="memdesc:aa5ca8083da245fef389ebea24fb5b2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves all best Hyperplanes in the simplex corners at the beginning of the specified range.  <a href="#aa5ca8083da245fef389ebea24fb5b2ef">More...</a><br /></td></tr>
<tr class="separator:aa5ca8083da245fef389ebea24fb5b2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bddf7746d3f6c047a566db924ad8e7c"><td class="memTemplParams" colspan="2">template&lt;typename PIterator , typename VIterator &gt; </td></tr>
<tr class="memitem:a3bddf7746d3f6c047a566db924ad8e7c"><td class="memTemplItemLeft" align="right" valign="top">PIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a3bddf7746d3f6c047a566db924ad8e7c">extractBestUsefulPoints</a> (PIterator pbegin, PIterator pend, VIterator begin, VIterator end)</td></tr>
<tr class="memdesc:a3bddf7746d3f6c047a566db924ad8e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves all non-useful points at the end of the input range.  <a href="#a3bddf7746d3f6c047a566db924ad8e7c">More...</a><br /></td></tr>
<tr class="separator:a3bddf7746d3f6c047a566db924ad8e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf18c556e25f6605168c8bc1af9d08a3"><td class="memTemplParams" colspan="2">template&lt;typename NewIt , typename OldIt &gt; </td></tr>
<tr class="memitem:acf18c556e25f6605168c8bc1af9d08a3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">Point</a>, double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#acf18c556e25f6605168c8bc1af9d08a3">findVerticesNaive</a> (NewIt beginNew, NewIt endNew, OldIt alphasBegin, OldIt alphasEnd)</td></tr>
<tr class="memdesc:acf18c556e25f6605168c8bc1af9d08a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function implements a naive vertex enumeration algorithm.  <a href="#acf18c556e25f6605168c8bc1af9d08a3">More...</a><br /></td></tr>
<tr class="separator:acf18c556e25f6605168c8bc1af9d08a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb6f10d44e72fd42be85dd0dd16c65d"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:aacb6f10d44e72fd42be85dd0dd16c65d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aacb6f10d44e72fd42be85dd0dd16c65d">computeOptimisticValue</a> (const <a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">Point</a> &amp;p, It pvBegin, It pvEnd)</td></tr>
<tr class="memdesc:aacb6f10d44e72fd42be85dd0dd16c65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the optimistic value of a point given known vertices and values.  <a href="#aacb6f10d44e72fd42be85dd0dd16c65d">More...</a><br /></td></tr>
<tr class="separator:aacb6f10d44e72fd42be85dd0dd16c65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33180c05494468c0f7afa2262384ce7"><td class="memItemLeft" align="right" valign="top">static std::uniform_real_distribution&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aa33180c05494468c0f7afa2262384ce7">probabilityDistribution</a> (0.0, 1.0)</td></tr>
<tr class="separator:aa33180c05494468c0f7afa2262384ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4052078699d21068b648273ec9dcf6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d4052078699d21068b648273ec9dcf6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a5d4052078699d21068b648273ec9dcf6">isProbability</a> (const size_t d, const T &amp;in)</td></tr>
<tr class="memdesc:a5d4052078699d21068b648273ec9dcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether the supplied vector is a correct probability vector.  <a href="#a5d4052078699d21068b648273ec9dcf6">More...</a><br /></td></tr>
<tr class="separator:a5d4052078699d21068b648273ec9dcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename G &gt; </td></tr>
<tr class="memitem:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad73352f6ce65aa95f76b7399cf0d2cb0">sampleProbability</a> (const size_t d, const T &amp;in, G &amp;generator)</td></tr>
<tr class="memdesc:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples an index from a probability vector.  <a href="#ad73352f6ce65aa95f76b7399cf0d2cb0">More...</a><br /></td></tr>
<tr class="separator:ad73352f6ce65aa95f76b7399cf0d2cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a31fb7fd3eb6b455f39a1bd388a5fd264">sampleProbability</a> (const size_t d, const SparseMatrix2D::ConstRowXpr &amp;in, G &amp;generator)</td></tr>
<tr class="memdesc:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function samples an index from a sparse probability vector.  <a href="#a31fb7fd3eb6b455f39a1bd388a5fd264">More...</a><br /></td></tr>
<tr class="separator:a31fb7fd3eb6b455f39a1bd388a5fd264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476a8ac48b42df366183a01594f78dac"><td class="memTemplParams" colspan="2">template&lt;typename G &gt; </td></tr>
<tr class="memitem:a476a8ac48b42df366183a01594f78dac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a476a8ac48b42df366183a01594f78dac">makeRandomProbability</a> (const size_t S, G &amp;generator)</td></tr>
<tr class="memdesc:a476a8ac48b42df366183a01594f78dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generates a random probability vector.  <a href="#a476a8ac48b42df366183a01594f78dac">More...</a><br /></td></tr>
<tr class="separator:a476a8ac48b42df366183a01594f78dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e60a055a590bbd22deb801d1a0121a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a0e60a055a590bbd22deb801d1a0121a6">checkEqualProbability</a> (const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;lhs, const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a0e60a055a590bbd22deb801d1a0121a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks whether two input ProbabilityVector are equal.  <a href="#a0e60a055a590bbd22deb801d1a0121a6">More...</a><br /></td></tr>
<tr class="separator:a0e60a055a590bbd22deb801d1a0121a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d02a7b4abada909d8d0b620496d381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad1d02a7b4abada909d8d0b620496d381">projectToProbability</a> (const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;v)</td></tr>
<tr class="memdesc:ad1d02a7b4abada909d8d0b620496d381"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function projects the input vector to a valid probability space.  <a href="#ad1d02a7b4abada909d8d0b620496d381">More...</a><br /></td></tr>
<tr class="separator:ad1d02a7b4abada909d8d0b620496d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea709246c227f35a91ffaa8de6e5c8d0"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aea709246c227f35a91ffaa8de6e5c8d0"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#aea709246c227f35a91ffaa8de6e5c8d0">extractDominated</a> (const size_t N, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:aea709246c227f35a91ffaa8de6e5c8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds and moves all Vectors in the range that are dominated by others.  <a href="#aea709246c227f35a91ffaa8de6e5c8d0">More...</a><br /></td></tr>
<tr class="separator:aea709246c227f35a91ffaa8de6e5c8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4ebce44b33756c860b64efc39426bd"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:adb4ebce44b33756c860b64efc39426bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#adb4ebce44b33756c860b64efc39426bd">iter_swap</a> (Iterator lhs, Iterator rhs)</td></tr>
<tr class="memdesc:adb4ebce44b33756c860b64efc39426bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function swaps the objects pointed by the two iterators.  <a href="#adb4ebce44b33756c860b64efc39426bd">More...</a><br /></td></tr>
<tr class="separator:adb4ebce44b33756c860b64efc39426bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7ac7114c76d8082333e9222fd1aac187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceAIToolbox.html#af6eb1f8c89dcca62cbe9912b6ec77d33">AILoggerFun</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a7ac7114c76d8082333e9222fd1aac187">AILogger</a> = nullptr</td></tr>
<tr class="memdesc:a7ac7114c76d8082333e9222fd1aac187"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pointer defines the function used to log.  <a href="#a7ac7114c76d8082333e9222fd1aac187">More...</a><br /></td></tr>
<tr class="separator:a7ac7114c76d8082333e9222fd1aac187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc7257db498e0170e525c36cbf69443"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structAIToolbox_1_1NoCheck.html">AIToolbox::NoCheck</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a8bc7257db498e0170e525c36cbf69443">NO_CHECK</a></td></tr>
<tr class="separator:a8bc7257db498e0170e525c36cbf69443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395f82018bc6d027736805fec404d482"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#a395f82018bc6d027736805fec404d482">equalToleranceSmall</a> = 0.000001</td></tr>
<tr class="memdesc:a395f82018bc6d027736805fec404d482"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the max absolute difference for which two values can be considered equal.  <a href="#a395f82018bc6d027736805fec404d482">More...</a><br /></td></tr>
<tr class="separator:a395f82018bc6d027736805fec404d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fe7471894e7e26ec5a51003997d258"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceAIToolbox.html#ad6fe7471894e7e26ec5a51003997d258">equalToleranceGeneral</a> = 0.00000000001</td></tr>
<tr class="separator:ad6fe7471894e7e26ec5a51003997d258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af6eb1f8c89dcca62cbe9912b6ec77d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6eb1f8c89dcca62cbe9912b6ec77d33">&#9670;&nbsp;</a></span>AILoggerFun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#af6eb1f8c89dcca62cbe9912b6ec77d33">AIToolbox::AILoggerFun</a> = typedef void(int, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1f932b6473be1c052e5f14aa85180d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f932b6473be1c052e5f14aa85180d0">&#9670;&nbsp;</a></span>copy_const_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CopiedType , typename ConstReference &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ae1f932b6473be1c052e5f14aa85180d0">AIToolbox::copy_const_t</a> = typedef typename <a class="el" href="structAIToolbox_1_1copy__const.html">copy_const</a>&lt;CopiedType, ConstReference&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a967d7ac0afaa61470bc00b04df196dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967d7ac0afaa61470bc00b04df196dca">&#9670;&nbsp;</a></span>Hyperplane</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a967d7ac0afaa61470bc00b04df196dca">AIToolbox::Hyperplane</a> = typedef <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d66d3e9eba8d23aeef6c6b865b6965a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d66d3e9eba8d23aeef6c6b865b6965a">&#9670;&nbsp;</a></span>Matrix2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">AIToolbox::Matrix2D</a> = typedef Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor | Eigen::AutoAlign&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae816d088c18d4f3e13c83ae29904ef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae816d088c18d4f3e13c83ae29904ef94">&#9670;&nbsp;</a></span>Matrix3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ae816d088c18d4f3e13c83ae29904ef94">AIToolbox::Matrix3D</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa7541eece4eef765b312dc4b686852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7541eece4eef765b312dc4b686852d">&#9670;&nbsp;</a></span>Matrix4D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#aaa7541eece4eef765b312dc4b686852d">AIToolbox::Matrix4D</a> = typedef boost::multi_array&lt;<a class="el" href="namespaceAIToolbox.html#a9d66d3e9eba8d23aeef6c6b865b6965a">Matrix2D</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fc5e85a0aaffacedefb093e4cbef173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc5e85a0aaffacedefb093e4cbef173">&#9670;&nbsp;</a></span>Point</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">AIToolbox::Point</a> = typedef <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4149b71e91dee03ad9d0c8c207eddf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4149b71e91dee03ad9d0c8c207eddf0">&#9670;&nbsp;</a></span>ProbabilityVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">AIToolbox::ProbabilityVector</a> = typedef <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09b5db736a97adb3698ffa04ea3f4aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b5db736a97adb3698ffa04ea3f4aa4">&#9670;&nbsp;</a></span>RandomEngine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a09b5db736a97adb3698ffa04ea3f4aa4">AIToolbox::RandomEngine</a> = typedef std::mt19937</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f42a5910cd868eb0af71b7491d420d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f42a5910cd868eb0af71b7491d420d">&#9670;&nbsp;</a></span>remove_cv_ref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a03f42a5910cd868eb0af71b7491d420d">AIToolbox::remove_cv_ref_t</a> = typedef typename <a class="el" href="structAIToolbox_1_1remove__cv__ref.html">remove_cv_ref</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab00da5abb5609a6454852aa726d67161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00da5abb5609a6454852aa726d67161">&#9670;&nbsp;</a></span>SparseMatrix2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">AIToolbox::SparseMatrix2D</a> = typedef Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dac40c8fbdb76d149b6cbee1868b0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dac40c8fbdb76d149b6cbee1868b0c9">&#9670;&nbsp;</a></span>SparseMatrix2DLong</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a8dac40c8fbdb76d149b6cbee1868b0c9">AIToolbox::SparseMatrix2DLong</a> = typedef Eigen::SparseMatrix&lt;long, Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92d1ba8e10537e996faadb65f9c1fa77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d1ba8e10537e996faadb65f9c1fa77">&#9670;&nbsp;</a></span>SparseMatrix3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a92d1ba8e10537e996faadb65f9c1fa77">AIToolbox::SparseMatrix3D</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1d4d92e6349e16ab51cc2b3b328750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1d4d92e6349e16ab51cc2b3b328750">&#9670;&nbsp;</a></span>SparseMatrix3DLong</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a1c1d4d92e6349e16ab51cc2b3b328750">AIToolbox::SparseMatrix3DLong</a> = typedef std::vector&lt;<a class="el" href="namespaceAIToolbox.html#a8dac40c8fbdb76d149b6cbee1868b0c9">SparseMatrix2DLong</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5615bfca915406da608cea51152cfe5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5615bfca915406da608cea51152cfe5b">&#9670;&nbsp;</a></span>SparseMatrix4D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a5615bfca915406da608cea51152cfe5b">AIToolbox::SparseMatrix4D</a> = typedef boost::multi_array&lt;<a class="el" href="namespaceAIToolbox.html#ab00da5abb5609a6454852aa726d67161">SparseMatrix2D</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af774ebb18ec376e43d77e908e3854370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af774ebb18ec376e43d77e908e3854370">&#9670;&nbsp;</a></span>Table2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#af774ebb18ec376e43d77e908e3854370">AIToolbox::Table2D</a> = typedef boost::multi_array&lt;double, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fa914363e6f779a2ba9f92ea654b90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa914363e6f779a2ba9f92ea654b90a">&#9670;&nbsp;</a></span>Table3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a7fa914363e6f779a2ba9f92ea654b90a">AIToolbox::Table3D</a> = typedef boost::multi_array&lt;double, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e6976de7a0159cd1630c4f2553fc9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6976de7a0159cd1630c4f2553fc9f3">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">AIToolbox::Vector</a> = typedef Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9f6c1c85280fc7a2d5c2cf96c72ca770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6c1c85280fc7a2d5c2cf96c72ca770">&#9670;&nbsp;</a></span>ballsBins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::ballsBins </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>balls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of balls/bins combinations. </p>
<p>This function returns the number of combinations in which you can split a set of indistinguishable balls into a set of distinguishable bins.</p>
<p>This is equivalent to starsBars(balls, bins - 1).</p>
<p>Note: bins shall NOT be equal to 0. </p>

</div>
</div>
<a id="a67f283ebe30cd11e1eead7a814057945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f283ebe30cd11e1eead7a814057945">&#9670;&nbsp;</a></span>checkDifferentGeneral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentGeneral </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles are reasonably different. </p>
<p>The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are far away enough, false otherwise. </dd></dl>

</div>
</div>
<a id="a65413c83ea777c89684f5d901ea33679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65413c83ea777c89684f5d901ea33679">&#9670;&nbsp;</a></span>checkDifferentGeneral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentGeneral </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a given vector does not contain only the stated value. </p>
<dl class="section return"><dt>Returns</dt><dd>True if not all elements are equal to the input. </dd></dl>

</div>
</div>
<a id="add1da51b88333c412b0978a7e95581f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1da51b88333c412b0978a7e95581f1">&#9670;&nbsp;</a></span>checkDifferentSmall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentSmall </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles near [0,1] are reasonably different. </p>
<p>If the numbers are not near [0,1], the result is not guaranteed to be what may be expected. The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are far away enough, false otherwise. </dd></dl>

</div>
</div>
<a id="a6797db6216af3a252546a74690bda979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6797db6216af3a252546a74690bda979">&#9670;&nbsp;</a></span>checkDifferentSmall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkDifferentSmall </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a given vector does not contain only the stated value. </p>
<dl class="section return"><dt>Returns</dt><dd>True if not all elements are equal to the input. </dd></dl>

</div>
</div>
<a id="a1cb49a3d6b7ce2588edec044a541e88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb49a3d6b7ce2588edec044a541e88e">&#9670;&nbsp;</a></span>checkEqualGeneral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualGeneral </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles are reasonably equal. </p>
<p>The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are close enough, false otherwise. </dd></dl>

</div>
</div>
<a id="a71946ca7560a469505d9e449841b40d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71946ca7560a469505d9e449841b40d1">&#9670;&nbsp;</a></span>checkEqualGeneral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualGeneral </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a given vector only contains the stated value. </p>
<p>This function compares using <a class="el" href="namespaceAIToolbox.html#a1cb49a3d6b7ce2588edec044a541e88e" title="This function checks if two doubles are reasonably equal. ">checkEqualGeneral(double, double)</a>;</p>
<dl class="section return"><dt>Returns</dt><dd>True if all elements are compared equal to the input. </dd></dl>

</div>
</div>
<a id="a0e60a055a590bbd22deb801d1a0121a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e60a055a590bbd22deb801d1a0121a6">&#9670;&nbsp;</a></span>checkEqualProbability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualProbability </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks whether two input ProbabilityVector are equal. </p>
<p>This function is approximate. It assumes that the vectors are valid, so they must sum up to one, and each element must be between zero and one. The vector must also be of the same size.</p>
<p>This function is approximate, as we're dealing with floating point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side to check. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the two ProbabilityVectors are the same. </dd></dl>

</div>
</div>
<a id="a164ff36d8475927a491a18c990a9e199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164ff36d8475927a491a18c990a9e199">&#9670;&nbsp;</a></span>checkEqualSmall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualSmall </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if two doubles near [0,1] are reasonably equal. </p>
<p>If the numbers are not near [0,1], the result is not guaranteed to be what may be expected. The order of the parameters is not important.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second number to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the two numbers are close enough, false otherwise. </dd></dl>

</div>
</div>
<a id="a18765a780a9488b129cb8334e16e370a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18765a780a9488b129cb8334e16e370a">&#9670;&nbsp;</a></span>checkEqualSmall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::checkEqualSmall </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether a given vector only contains the stated value. </p>
<p>This function compares using <a class="el" href="namespaceAIToolbox.html#a164ff36d8475927a491a18c990a9e199" title="This function checks if two doubles near [0,1] are reasonably equal. ">checkEqualSmall(double, double)</a>;</p>
<dl class="section return"><dt>Returns</dt><dd>True if all elements are compared equal to the input. </dd></dl>

</div>
</div>
<a id="aacb6f10d44e72fd42be85dd0dd16c65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb6f10d44e72fd42be85dd0dd16c65d">&#9670;&nbsp;</a></span>computeOptimisticValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double AIToolbox::computeOptimisticValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>pvBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>pvEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the optimistic value of a point given known vertices and values. </p>
<p>This function computes an <a class="el" href="classAIToolbox_1_1LP.html" title="This class presents a common interface for solving Linear Programming problems. ">LP</a> to determine the best possible value of a point given all known best vertices around it.</p>
<p>This function is needed in multi-objective settings (rather than POMDPs), since the step where we compute the optimal value for a given point is extremely expensive (it requires solving a full <a class="el" href="namespaceAIToolbox_1_1MDP.html">MDP</a>). Thus linear programming is used in order to determine an optimistic bound when deciding the next point to extract from the queue during the linear support process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point where we want to compute the best possible value. </td></tr>
    <tr><td class="paramname">pvBegin</td><td>The start of the range of point-value pairs representing all surrounding vertices. </td></tr>
    <tr><td class="paramname">pvEnd</td><td>The end of that same range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The best possible value that the input point can have given the known vertices. </dd></dl>

</div>
</div>
<a id="adf3316313e5c38bb940a665f55db9a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3316313e5c38bb940a665f55db9a04">&#9670;&nbsp;</a></span>copyTable3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::copyTable3D </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a 3d container into another 3d container. </p>
<p>The containers needs to support data access through operator[]. In addition, the dimensions of the containers must match the ones specified.</p>
<p>This is important, as this function DOES NOT perform any size checks on the containers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the input container. </td></tr>
    <tr><td class="paramname">U</td><td>Type of the output container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input container. </td></tr>
    <tr><td class="paramname">out</td><td>Output container. </td></tr>
    <tr><td class="paramname">d1</td><td>First dimension of the containers. </td></tr>
    <tr><td class="paramname">d2</td><td>Second dimension of the containers. </td></tr>
    <tr><td class="paramname">d3</td><td>Third dimension of the containers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a861a12a2c8b1399d1ee2da0af575481c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861a12a2c8b1399d1ee2da0af575481c">&#9670;&nbsp;</a></span>extractBestAtPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::extractBestAtPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves the Hyperplane with the highest value for the given point at the beginning of the specified range. </p>
<p>This function uses an already existing bound containing previously marked useful hyperplanes. The order is 'begin'-&gt;'bound'-&gt;'end', where bound may be equal to end where no previous bound exists. The found hyperplane is moved between 'begin' and 'bound', but only if it was not there previously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point where we need to check the value </td></tr>
    <tr><td class="paramname">begin</td><td>The begin of the search range. </td></tr>
    <tr><td class="paramname">bound</td><td>The begin of the 'useful' range. </td></tr>
    <tr><td class="paramname">end</td><td>The range end to be checked. It is NOT included in the search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bound iterator. </dd></dl>

</div>
</div>
<a id="aa5ca8083da245fef389ebea24fb5b2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ca8083da245fef389ebea24fb5b2ef">&#9670;&nbsp;</a></span>extractBestAtSimplexCorners()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::extractBestAtSimplexCorners </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves all best Hyperplanes in the simplex corners at the beginning of the specified range. </p>
<p>What this function does is to find out which hyperplanes give the highest value in the corner points. Since multiple corners may use the same hyperplanes, the number of found hyperplanes may not be the same as the number of corners.</p>
<p>This function uses an already existing bound containing previously marked useful hyperplanes. The order is 'begin'-&gt;'bound'-&gt;'end', where bound may be equal to end where no previous bound exists. All found hyperplanes are added between 'begin' and 'bound', but only if they were not there previously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The number of corners of the simplex. </td></tr>
    <tr><td class="paramname">begin</td><td>The begin of the search range. </td></tr>
    <tr><td class="paramname">bound</td><td>The begin of the 'useful' range. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the search range. It is NOT included in the search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bound iterator. </dd></dl>

</div>
</div>
<a id="a3bddf7746d3f6c047a566db924ad8e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bddf7746d3f6c047a566db924ad8e7c">&#9670;&nbsp;</a></span>extractBestUsefulPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PIterator , typename VIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PIterator AIToolbox::extractBestUsefulPoints </td>
          <td>(</td>
          <td class="paramtype">PIterator&#160;</td>
          <td class="paramname"><em>pbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PIterator&#160;</td>
          <td class="paramname"><em>pend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves all non-useful points at the end of the input range. </p>
<p>This function helps remove points which do not support any hyperplane and are thus not useful for improving the overall surface.</p>
<p>This function moves all non-useful points at the end of the input range, and returns the resulting iterator pointing to the first non-useful point.</p>
<p>When multiple Points support the same Hyperplane, the one with the best value is returned.</p>
<p>The Hyperplane range may contain elements which are not supported by any of the input Points (although if they exist they may slow down the function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbegin</td><td>The beginning of the Point range to check. </td></tr>
    <tr><td class="paramname">pend</td><td>The end of the Point range to check. </td></tr>
    <tr><td class="paramname">begin</td><td>The beginning of the Hyperplane range to check against. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the Hyperplane range to check against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first non-useful Point. </dd></dl>

</div>
</div>
<a id="aea709246c227f35a91ffaa8de6e5c8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea709246c227f35a91ffaa8de6e5c8d0">&#9670;&nbsp;</a></span>extractDominated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::extractDominated </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds and moves all Vectors in the range that are dominated by others. </p>
<p>This function performs simple comparisons between all Vectors in the range, and is thus much more performant than a full-fledged prune, since that would need to solve multiple linear programming problems. However, this function will not return the truly parsimonious set of Vectors, as its pruning powers are limited.</p>
<p>Dominated elements will be moved at the end of the range for safe removal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The number of elements in each Vector. </td></tr>
    <tr><td class="paramname">begin</td><td>The begin of the list that needs to be pruned. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the list that needs to be pruned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator that separates dominated elements with non-pruned. </dd></dl>

</div>
</div>
<a id="acdeffa64d9078567c3d3e61e92cf0c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdeffa64d9078567c3d3e61e92cf0c6f">&#9670;&nbsp;</a></span>findBestAtPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::findBestAtPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns an iterator pointing to the best Hyperplane for the specified point. </p>
<p>Given a list of hyperplanes as a surface, this function returns the hyperplane which provides the highest value at the specified point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point where we need to check the value </td></tr>
    <tr><td class="paramname">begin</td><td>The start of the range to look in. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to look in (excluded). </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to double, which gets set to the value of the given point with the found Hyperplane.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the best choice in range. </dd></dl>

</div>
</div>
<a id="a69fa3979f3ccb728db8fd16668bce211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fa3979f3ccb728db8fd16668bce211">&#9670;&nbsp;</a></span>findBestAtSimplexCorner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator AIToolbox::findBestAtSimplexCorner </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns an iterator pointing to the best Hyperplane for the specified corner of the simplex space. </p>
<p>This function is slightly more efficient than findBestAtPoint for a simplex corner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">corner</td><td>The corner of the simplex space we are checking. </td></tr>
    <tr><td class="paramname">begin</td><td>The start of the range to look in. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the range to look in (excluded).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the best choice in range. </dd></dl>

</div>
</div>
<a id="acf18c556e25f6605168c8bc1af9d08a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf18c556e25f6605168c8bc1af9d08a3">&#9670;&nbsp;</a></span>findVerticesNaive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewIt , typename OldIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="namespaceAIToolbox.html#a9fc5e85a0aaffacedefb093e4cbef173">Point</a>, double&gt; &gt; AIToolbox::findVerticesNaive </td>
          <td>(</td>
          <td class="paramtype">NewIt&#160;</td>
          <td class="paramname"><em>beginNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewIt&#160;</td>
          <td class="paramname"><em>endNew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OldIt&#160;</td>
          <td class="paramname"><em>alphasBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OldIt&#160;</td>
          <td class="paramname"><em>alphasEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function implements a naive vertex enumeration algorithm. </p>
<p>This function goes through every subset of planes of size S, and finds all vertices it can. In particular, it goes through the first list one element at a time, and joins it with S-1 elements from the second list.</p>
<p>Even more precisely, we take &gt;= 1 elements from the second list. The remaining elements (so that in total we still use S-1) are simply the simplex boundaries, which allows us to find the corners located there.</p>
<p>This method may find duplicate vertices (it does not bother to prune them), as a vertex can be in the convergence of more than S planes.</p>
<p>The advantage is that we do not need any linear programming, and simple matrix decomposition techniques suffice.</p>
<p>Warning: the values of each vertex depends on the planes it has been found of, and thus may <em>not</em> be the true value if considering all planes at the same time!</p>
<p>This function works on ranges of Vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beginNew</td><td>The beginning of the range of the planes to find vertices for. </td></tr>
    <tr><td class="paramname">endNew</td><td>The end of the range of the planes to find vertices for. </td></tr>
    <tr><td class="paramname">alphasBegin</td><td>The beginning of the range of all other planes. </td></tr>
    <tr><td class="paramname">alphasEnd</td><td>The end of the range of all other planes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-unique list of all the vertices found. </dd></dl>

</div>
</div>
<a id="afc040c10bbec513dac4ee154328d799f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc040c10bbec513dac4ee154328d799f">&#9670;&nbsp;</a></span>IndexMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIToolbox_1_1IndexMap.html">AIToolbox::IndexMap</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classAIToolbox_1_1IndexMap.html">IndexMap</a>&lt; std::vector&lt; T &gt;, Container &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ad1be4bb3c810a6b25373d91a28038e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad1be4bb3c810a6b25373d91a28038e">&#9670;&nbsp;</a></span>IndexSkipMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIToolbox_1_1IndexSkipMap.html">AIToolbox::IndexSkipMap</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classAIToolbox_1_1IndexSkipMap.html">IndexSkipMap</a>&lt; std::vector&lt; T &gt;, Container &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d4052078699d21068b648273ec9dcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4052078699d21068b648273ec9dcf6">&#9670;&nbsp;</a></span>isProbability()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::isProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks whether the supplied vector is a correct probability vector. </p>
<p>This function verifies basic probability conditions on the supplied container. The sum of all elements must be 1, and all elements must be &gt;= 0 and &lt;= 1.</p>
<p>The container needs to support data access through operator[]. In addition, the dimension of the container must match the one provided as argument.</p>
<p>This is important, as this function DOES NOT perform any size checks on the external container.</p>
<p>Internal values of the container will be converted to double, so the conversion T to double must be possible.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The external transition container type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external transitions container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the container satisfies probability constraints, and false otherwise. </dd></dl>

</div>
</div>
<a id="adb4ebce44b33756c860b64efc39426bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4ebce44b33756c860b64efc39426bd">&#9670;&nbsp;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AIToolbox::iter_swap </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function swaps the objects pointed by the two iterators. </p>
<p>This function is needed in order to be able to treat in the same way normal iterators and proxy iterators (such as boost::transform_iterator). This allows us to write algorithms that operate on a specific part of the data, but can alter the original range as needed. </p>

</div>
</div>
<a id="a476a8ac48b42df366183a01594f78dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476a8ac48b42df366183a01594f78dac">&#9670;&nbsp;</a></span>makeRandomProbability()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> AIToolbox::makeRandomProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function generates a random probability vector. </p>
<p>This function will sample uniformly from the simplex space with the specified number of dimensions.</p>
<p>S must be at least one or we don't guarantee any behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The number of entries of the output vector. </td></tr>
    <tr><td class="paramname">generator</td><td>A random number generator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new random probability vector. </dd></dl>

</div>
</div>
<a id="ade5a791c00b531a438fd130591ee0809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5a791c00b531a438fd130591ee0809">&#9670;&nbsp;</a></span>nChooseK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::nChooseK </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns (n k); i.e. n choose k. </p>

</div>
</div>
<a id="aaecaab4f7eee1001fa0c46fb93c98201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaecaab4f7eee1001fa0c46fb93c98201">&#9670;&nbsp;</a></span>nonZeroBallsBins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::nonZeroBallsBins </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>balls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of balls/bins combinations. </p>
<p>This function returns the number of combinations in which you can split a set of indistinguishable balls into a set of distinguishable bins, where no bin can be empty.</p>
<p>This is equivalent to nonZeroStarsBars(balls, bins - 1).</p>
<p>Note: bins shall NOT be equal to 0. </p>

</div>
</div>
<a id="a089de7e55bbd13310ce6f3d5296932af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089de7e55bbd13310ce6f3d5296932af">&#9670;&nbsp;</a></span>nonZeroStarsBars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::nonZeroStarsBars </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of stars/bars combinations. </p>
<p>This function returns the number of combinations for dividing a set of stars with <code>bars</code> number of elements, where no two bars can be adjacent. </p>

</div>
</div>
<a id="a6ca50b6d2585387be42d0ae76205f34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca50b6d2585387be42d0ae76205f34a">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; AIToolbox::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAIToolbox_1_1Statistics.html">Statistics</a> &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes the output of the <a class="el" href="classAIToolbox_1_1Statistics.html" title="This class registers sets of data and computes statistics about it. ">Statistics</a> to the stream. </p>
<p>The output will contain a series of lines, each formed by: timestep, mean, cumulative mean, standard deviation and cumulative standard deviation.</p>
<p>The output is GnuPlot friendly!</p>
<p>Note that each reprint will recompute the statistics from scratch, as they are not cached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">rh</td><td>The <a class="el" href="classAIToolbox_1_1Statistics.html" title="This class registers sets of data and computes statistics about it. ">Statistics</a> to get data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream. </dd></dl>

</div>
</div>
<a id="aa33180c05494468c0f7afa2262384ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33180c05494468c0f7afa2262384ce7">&#9670;&nbsp;</a></span>probabilityDistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uniform_real_distribution&lt;double&gt; AIToolbox::probabilityDistribution </td>
          <td>(</td>
          <td class="paramtype">0.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname"><em>0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1d02a7b4abada909d8d0b620496d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d02a7b4abada909d8d0b620496d381">&#9670;&nbsp;</a></span>projectToProbability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox.html#af4149b71e91dee03ad9d0c8c207eddf0">ProbabilityVector</a> AIToolbox::projectToProbability </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceAIToolbox.html#a1e6976de7a0159cd1630c4f2553fc9f3">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function projects the input vector to a valid probability space. </p>
<p>This function finds the closest valid ProbabilityVector to the input vector. The distance measure used here is the sum of the absolute values of the element-wise difference between the input and the output.</p>
<p>When it has a choice, it tries to preserve the "shape" of the input and not arbitrarily change elements around.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to project to a valid probability space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closes valid probability vector to the input. </dd></dl>

</div>
</div>
<a id="ad73352f6ce65aa95f76b7399cf0d2cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73352f6ce65aa95f76b7399cf0d2cb0">&#9670;&nbsp;</a></span>sampleProbability() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t AIToolbox::sampleProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples an index from a probability vector. </p>
<p>This function randomly samples an index between 0 and d, given a vector containing the probabilities of sampling each of the indexes.</p>
<p>For performance reasons this function does not verify that the input container is effectively a probability.</p>
<p>The generator has to be supplied to the function, so that different objects are able to maintain different generators, to reduce correlations between different samples. The generator has to be compatible with std::uniform_real_distribution&lt;double&gt;, since that is what is used to obtain the random sample.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the container vector to sample. </td></tr>
    <tr><td class="paramname">G</td><td>The type of the generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external probability container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container. </td></tr>
    <tr><td class="paramname">generator</td><td>The generator used to sample.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index in range [0,d-1]. </dd></dl>

</div>
</div>
<a id="a31fb7fd3eb6b455f39a1bd388a5fd264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fb7fd3eb6b455f39a1bd388a5fd264">&#9670;&nbsp;</a></span>sampleProbability() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t AIToolbox::sampleProbability </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseMatrix2D::ConstRowXpr &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function samples an index from a sparse probability vector. </p>
<p>This function randomly samples an index between 0 and d, given a vector containing the probabilities of sampling each of the indexes.</p>
<p>For performance reasons this function does not verify that the input container is effectively a probability.</p>
<p>The generator has to be supplied to the function, so that different objects are able to maintain different generators, to reduce correlations between different samples. The generator has to be compatible with std::uniform_real_distribution&lt;double&gt;, since that is what is used to obtain the random sample.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>The type of the generator used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The external probability container. </td></tr>
    <tr><td class="paramname">d</td><td>The size of the supplied container. </td></tr>
    <tr><td class="paramname">generator</td><td>The generator used to sample.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index in range [0,d-1]. </dd></dl>

</div>
</div>
<a id="aa39713f004f1572ab84fb4ab4d9f44f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39713f004f1572ab84fb4ab4d9f44f3">&#9670;&nbsp;</a></span>sequential_sorted_contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::sequential_sorted_contains </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">decltype(v[0])&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether a sorted range contains a given element, via sequential scan. </p>
<p>The idea behind this function is that for small sorted vectors it is faster to do a sequential scan rather than employing the heavy handed technique of binary search.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The type of the vector to be scanned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to be scanned. </td></tr>
    <tr><td class="paramname">elem</td><td>The element to be looked for in the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vector contains that element, false otherwise. </dd></dl>

</div>
</div>
<a id="acb9131cfadf0600e435b545dbf0b5fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9131cfadf0600e435b545dbf0b5fc9">&#9670;&nbsp;</a></span>sequential_sorted_contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AIToolbox::sequential_sorted_contains </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>elems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns whether a sorted range contains another sorted range, via sequential scan. </p>
<p>Note: This function assumes that the contained vector is smaller or equal in size of the vector to be searched.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The type of the vector to be scanned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to be scanned. </td></tr>
    <tr><td class="paramname">elems</td><td>The vector that must be contained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vector contains all elements from the input, false otherwise. </dd></dl>

</div>
</div>
<a id="acc2c6fcda7af327c205dae20fc162d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2c6fcda7af327c205dae20fc162d35">&#9670;&nbsp;</a></span>starsBars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AIToolbox::starsBars </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of stars/bars combinations. </p>
<p>This function returns the number of combinations for dividing a set of stars with <code>bars</code> number of elements. </p>

</div>
</div>
<a id="a111282b4c465f34023497869fdeecd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111282b4c465f34023497869fdeecd58">&#9670;&nbsp;</a></span>veccmp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int AIToolbox::veccmp </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two general vectors of equal size lexicographically. </p>
<p>Note that veccmp reports equality only if the elements are all exactly the same. You should not use this function to compare floating point numbers unless you know what you are doing.</p>
<p>Note: This function assumes that the inputs are equally sized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand size of the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand size of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the lhs is greater than the rhs, 0 if they are equal, -1 otherwise. </dd></dl>

</div>
</div>
<a id="a2ad90c42f9cf72812707724c6a669161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad90c42f9cf72812707724c6a669161">&#9670;&nbsp;</a></span>veccmpGeneral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int AIToolbox::veccmpGeneral </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two general vectors of equal size lexicographically. </p>
<p>This function considers two elements equal using the checkEqualGeneral function.</p>
<p>Note: This function assumes that the inputs are equally sized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand size of the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand size of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the lhs is greater than the rhs, 0 if they are equal, -1 otherwise. </dd></dl>

</div>
</div>
<a id="ad0927a8f10c7aa36aa7d341fab1834fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0927a8f10c7aa36aa7d341fab1834fc">&#9670;&nbsp;</a></span>veccmpSmall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int AIToolbox::veccmpSmall </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares two general vectors of equal size lexicographically. </p>
<p>Note that veccmpSmall considers two elements equal using the checkEqualSmall function.</p>
<p>Note: This function assumes that the inputs are equally sized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand size of the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand size of the comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the lhs is greater than the rhs, 0 if they are equal, -1 otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7ac7114c76d8082333e9222fd1aac187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac7114c76d8082333e9222fd1aac187">&#9670;&nbsp;</a></span>AILogger</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceAIToolbox.html#af6eb1f8c89dcca62cbe9912b6ec77d33">AILoggerFun</a>* AIToolbox::AILogger = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This pointer defines the function used to log. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="Logging.html">How to use AIToolbox logging facilities.</a> </dd></dl>

</div>
</div>
<a id="ad6fe7471894e7e26ec5a51003997d258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fe7471894e7e26ec5a51003997d258">&#9670;&nbsp;</a></span>equalToleranceGeneral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto AIToolbox::equalToleranceGeneral = 0.00000000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a relative term used in the checkEqualGeneral functions, where two values may be considered equal if they are within this percentage of each other. </p>

</div>
</div>
<a id="a395f82018bc6d027736805fec404d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395f82018bc6d027736805fec404d482">&#9670;&nbsp;</a></span>equalToleranceSmall</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto AIToolbox::equalToleranceSmall = 0.000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the max absolute difference for which two values can be considered equal. </p>

</div>
</div>
<a id="a8bc7257db498e0170e525c36cbf69443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc7257db498e0170e525c36cbf69443">&#9670;&nbsp;</a></span>NO_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structAIToolbox_1_1NoCheck.html">AIToolbox::NoCheck</a>  AIToolbox::NO_CHECK</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 1 2019 11:06:11 for AIToolbox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
